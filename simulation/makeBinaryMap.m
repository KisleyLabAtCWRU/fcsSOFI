%{
Function to create a custom binary map

Inpute:
type: type of map generated
settings: array of numbers which define random / structured generation

Return:
binaryMap: the 2D binary map

Type 1: Vertical channels
    Generates a map containing multiple vertical channels of custom thickness
    and custom seperation. Seperation can be set to increase each channel
    Settings must come in the following form:
    [height, width, thickness, seperation, seperationIncrease]
    height: Overall pixel height of map
    width: Overall pixel width of map
    thickness: How many pixels thick a channel is
    seperation: How many pixels seperate each channel
    seperationIncrease: How many pixels larger the seperation will be each channel

Type 2: Rings
    Generates a map of rings centered in the middle of the map. The rings
    can be spaced the same as the channels
    Settings must come in the following form:
    [height, width, thickness, seperation, seperationIncrease]
    height: Overall pixel height of map
    width: Overall pixel width of map
    thickness: How many pixels thick a ring is
    seperation: How many pixels seperate each ring
    seperationIncrease: How many pixels larger the seperation will be each ring

Type 3: Pores
    Generates a map containing a specific number of elipticle pores rotated
    at random angles. Does not support pores overlapping the edges.
    Settings must come in the following form:
    [height, width, numPores, poreR, poreSigma]
    height: Overall pixel height of map
    width: Overall pixel width of map
    numPores: The number of pores to be generated in the map
    poreR: The mean radius of a pore
    poreSigma: The standard deviation used when generating a pores actual radius
    
    The pores are generated by randomly picking a number from a normal
    distribution with the given mean (poreR) and standard deviation
    (poreSigma). Two different radiuses are generated for each pore (a
    horizontal and verical one) to create the elips shape. Positions of the
    pores are generated from a uniform random distribution.
%}
function [binaryMap] = makeBinaryMap(type, settings)

switch(type)
    case 1 
        binaryMap = makeChannels(settings);
    case 2
        binaryMap = makeRings(settings);
    case 3 
        binaryMap = makePores(settings);
end

end


function [binaryMap] = makeChannels(settings)
    height = settings(1);
    width = settings(2);
    thickness = settings(3);
    seperation = settings(4);
    seperationIncrease = settings(5);
    
    binaryMap = zeros(height, width);
    xMarker = seperation; % Starts first channel at seperation distance

    while (xMarker < width - thickness)
        binaryMap(:, xMarker:xMarker+thickness) = 1;
        xMarker = xMarker + thickness + seperation;
        seperation = seperation + seperationIncrease;
    end
    if (xMarker < width) % Add part of last channel if room
        binaryMap(:, xMarker:end) = 1;
    end
end


function [binaryMap] = makeRings(settings)
    height = settings(1);
    width = settings(2);
    thickness = settings(3);
    seperation = settings(4);
    seperationIncrease = settings(5);

    [x, y] = meshgrid(-width/2:width/2, -height/2:height/2); % Grid to find circle points
    binaryMap = zeros(size(x));
    rMarker = round(seperation/4); % Starts first channel at seperation distance

    while (rMarker < sqrt((height/2)^2 + (width/2)^2))
        % If values are both greater than seperation and less than thickness
        binaryMap((((x./rMarker).^2 + (y./rMarker).^2) > 1) & ...
            (((x./(rMarker+thickness)).^2 + (y./(rMarker+thickness)).^2) < 1)) = 1;
        rMarker = rMarker + thickness + seperation; % Place start of next ring
        seperation = seperation + seperationIncrease; % Increase speration
    end
end


function [binaryMap] = makePores(settings)

    height = settings(1);
    width = settings(2);
    numPores = settings(3);
    poreR = settings(5); % Average Pore Radius
    poreSigma = settings(4); % Pore Radius Standard Deviation

    binaryMap = zeros(height, width);

    for n = 1:numPores
        poreHR = round(normrnd(poreR, poreSigma));
        poreVR = round(normrnd(poreR, poreSigma));
        poreMaxR = max(poreVR, poreHR);

        i = randi([poreMaxR+1, height-poreMaxR]); % Generate pore center pos
        j = randi([poreMaxR+1, width-poreMaxR]);
        pore = makePore();
        binaryMap(i-poreMaxR:i+poreMaxR, j-poreMaxR:j+poreMaxR) = binaryMap(i-poreMaxR:i+poreMaxR, j-poreMaxR:j+poreMaxR) + pore;
    end
    
    binaryMap(binaryMap > 1) = 1;

    function [pore] = makePore()
        theta = rand * pi;
        [x, y] = meshgrid(-poreMaxR:poreMaxR);
        pore = zeros(size(x));
        pore((((x.*cos(theta)+y.*sin(theta)).^2/poreHR^2) + ((y.*cos(theta)-x.*sin(theta)).^2/poreVR^2)) < 1) = 1;
    end
end
